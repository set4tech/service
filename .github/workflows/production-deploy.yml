name: Production Deploy with Migration Testing

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  NODE_VERSION: '22'

jobs:
  # Job 1: Fast feedback on code quality
  lint-and-build:
    name: Lint, Type Check, Unit Tests, Build
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint

      - name: Type check
        run: npm run typecheck

      - name: Run unit tests
        run: npm test

      - name: Build application
        run: npm run build
        env:
          # Use dummy values for build verification
          NEXT_PUBLIC_SUPABASE_URL: https://dummy.supabase.co
          NEXT_PUBLIC_SUPABASE_ANON_KEY: dummy_key
          SUPABASE_SERVICE_ROLE_KEY: dummy_key
          AWS_S3_BUCKET_NAME: dummy-bucket
          NEXT_PUBLIC_S3_BUCKET_NAME: dummy-bucket

  # Job 2: Test migrations on production database branch
  test-migrations-on-prod-branch:
    name: Test Migrations on Production Branch
    runs-on: ubuntu-latest
    needs: lint-and-build
    # Run on PRs to main and pushes to main
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Check if migrations exist
        id: check-migrations
        run: |
          MIGRATION_COUNT=$(find supabase/migrations -name "*.sql" -type f | wc -l)
          echo "count=$MIGRATION_COUNT" >> $GITHUB_OUTPUT

          if [ "$MIGRATION_COUNT" -eq 0 ]; then
            echo "‚úÖ No migrations to test - skipping branch creation"
            echo "   This is expected if all migrations are already in production"
            echo "has_migrations=false" >> $GITHUB_OUTPUT
          else
            echo "üì¶ Found $MIGRATION_COUNT migration(s) to test"
            echo "has_migrations=true" >> $GITHUB_OUTPUT
          fi

      - name: Setup Node.js
        if: steps.check-migrations.outputs.has_migrations == 'true'
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Setup Supabase CLI
        if: steps.check-migrations.outputs.has_migrations == 'true'
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Install dependencies
        if: steps.check-migrations.outputs.has_migrations == 'true'
        run: npm ci

      - name: Setup and test database branch
        if: steps.check-migrations.outputs.has_migrations == 'true'
        id: setup-branch
        run: |
          echo "üîê Logging into Supabase..."
          supabase login --token ${{ secrets.SUPABASE_ACCESS_TOKEN }}

          echo "üîó Linking to production project..."
          supabase link --project-ref ${{ secrets.SUPABASE_PROD_PROJECT_REF }}

          # Create unique branch name
          BRANCH_NAME="ci-test-${{ github.run_id }}-${{ github.run_attempt }}"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

          echo "üåø Creating database branch: $BRANCH_NAME"
          supabase branches create $BRANCH_NAME

          echo "‚úÖ Branch creation initiated"

          # Wait for branch to be fully provisioned (can take 3-5 minutes)
          echo "‚è≥ Waiting for branch to be ready (this can take 3-5 minutes)..."
          MAX_ATTEMPTS=60
          ATTEMPT=0
          SLEEP_INTERVAL=5

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            BRANCH_STATUS=$(supabase branches list --output json | jq -r ".[] | select(.name == \"$BRANCH_NAME\") | .status")
            
            if [ "$BRANCH_STATUS" = "ACTIVE" ] || [ "$BRANCH_STATUS" = "ACTIVE_HEALTHY" ]; then
              echo "‚úÖ Branch is ready! (took $((ATTEMPT * SLEEP_INTERVAL)) seconds)"
              break
            elif [ "$BRANCH_STATUS" = "CREATING_PROJECT" ] || [ "$BRANCH_STATUS" = "CREATING_DATABASE" ] || [ "$BRANCH_STATUS" = "RUNNING_MIGRATIONS" ] || [ "$BRANCH_STATUS" = "PROVISIONING" ]; then
              ELAPSED=$((ATTEMPT * SLEEP_INTERVAL))
              echo "   Status: $BRANCH_STATUS (${ELAPSED}s elapsed)"
              sleep $SLEEP_INTERVAL
              ATTEMPT=$((ATTEMPT + 1))
            else
              echo "‚ùå Unexpected branch status: $BRANCH_STATUS"
              echo "   Branch may be in an error state. Check Supabase dashboard."
              exit 1
            fi
          done

          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "‚ùå Branch did not become ready within $((MAX_ATTEMPTS * SLEEP_INTERVAL)) seconds (5 minutes)"
            echo "   This may indicate an issue with Supabase branch provisioning"
            echo "   You can check branch status in your Supabase dashboard"
            exit 1
          fi

          # Check for migrations
          echo "üì¶ Checking for migrations to apply..."
          MIGRATION_COUNT=$(find supabase/migrations -name "*.sql" -type f | wc -l)

          if [ "$MIGRATION_COUNT" -eq 0 ]; then
            echo "‚ÑπÔ∏è  No new migrations to apply (supabase/migrations/ is empty)"
          else
            echo "üì¶ Found $MIGRATION_COUNT migration(s) to apply"
            
            # Get branch database URL (pooled connection)
            BRANCH_DB_URL=$(supabase branches get $BRANCH_NAME --output json | jq -r '.POSTGRES_URL')
            
            # Apply all pending migrations to the branch using db-url
            supabase db push --db-url "$BRANCH_DB_URL"
            
            echo "‚úÖ Migrations applied successfully"
          fi

          # Get branch connection details
          echo "üîç Getting branch connection details..."
          BRANCH_INFO=$(supabase branches get $BRANCH_NAME --output json)

          # Extract connection details
          BRANCH_URL=$(echo $BRANCH_INFO | jq -r '.SUPABASE_URL')
          BRANCH_ANON_KEY=$(echo $BRANCH_INFO | jq -r '.SUPABASE_ANON_KEY')
          BRANCH_SERVICE_KEY=$(echo $BRANCH_INFO | jq -r '.SUPABASE_SERVICE_ROLE_KEY')

          # Set as environment variables for next steps
          echo "BRANCH_URL=$BRANCH_URL" >> $GITHUB_ENV
          echo "BRANCH_ANON_KEY=$BRANCH_ANON_KEY" >> $GITHUB_ENV
          echo "BRANCH_SERVICE_KEY=$BRANCH_SERVICE_KEY" >> $GITHUB_ENV

          echo "‚úÖ Branch setup complete"
          echo "   Branch name: $BRANCH_NAME"
          echo "   Branch URL: $BRANCH_URL"

      - name: Install Playwright browsers
        if: steps.check-migrations.outputs.has_migrations == 'true'
        run: npx playwright install --with-deps chromium

      - name: Run E2E tests against migration branch
        if: steps.check-migrations.outputs.has_migrations == 'true'
        run: |
          echo "üß™ Running E2E tests against branch database..."
          echo "   Database URL: $BRANCH_URL"
          npm run test:e2e
        env:
          # Point tests to the branch database
          NEXT_PUBLIC_SUPABASE_URL: ${{ env.BRANCH_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ env.BRANCH_ANON_KEY }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ env.BRANCH_SERVICE_KEY }}

          # AWS credentials for screenshot uploads
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_S3_BUCKET_NAME: ${{ secrets.AWS_S3_BUCKET_NAME }}
          NEXT_PUBLIC_S3_BUCKET_NAME: ${{ secrets.AWS_S3_BUCKET_NAME }}

          # AI provider keys (may not be needed for all E2E tests)
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

      - name: Upload Playwright report
        if: always() && steps.check-migrations.outputs.has_migrations == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report-migration-test
          path: playwright-report/
          retention-days: 7

      - name: Cleanup database branch
        if: always() && steps.check-migrations.outputs.has_migrations == 'true'
        run: |
          BRANCH_NAME="${{ steps.setup-branch.outputs.branch_name }}"

          if [ -z "$BRANCH_NAME" ]; then
            echo "‚ö†Ô∏è  No branch name found, skipping cleanup"
            exit 0
          fi

          echo "üßπ Cleaning up database branch: $BRANCH_NAME"

          # Re-login and link for cleanup
          supabase login --token ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          supabase link --project-ref ${{ secrets.SUPABASE_PROD_PROJECT_REF }}

          # Force delete without confirmation
          supabase branches delete $BRANCH_NAME --force || echo "‚ö†Ô∏è  Branch may have already been deleted"

          echo "‚úÖ Cleanup complete"

  # Job 3: Apply migrations to production (only on main push, only if tests pass)
  apply-migrations-to-production:
    name: Apply Migrations to Production
    runs-on: ubuntu-latest
    needs: test-migrations-on-prod-branch
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Check if migrations exist
        id: check-migrations
        run: |
          MIGRATION_COUNT=$(find supabase/migrations -name "*.sql" -type f | wc -l)
          echo "count=$MIGRATION_COUNT" >> $GITHUB_OUTPUT

          if [ "$MIGRATION_COUNT" -eq 0 ]; then
            echo "‚úÖ No migrations to apply - skipping"
            echo "has_migrations=false" >> $GITHUB_OUTPUT
          else
            echo "üì¶ Found $MIGRATION_COUNT migration(s) to apply"
            echo "has_migrations=true" >> $GITHUB_OUTPUT
          fi

      - name: Setup Supabase CLI
        if: steps.check-migrations.outputs.has_migrations == 'true'
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Apply migrations to PRODUCTION
        if: steps.check-migrations.outputs.has_migrations == 'true'
        run: |
          echo "üîê Logging into Supabase..."
          supabase login --token ${{ secrets.SUPABASE_ACCESS_TOKEN }}

          echo "üîó Linking to production project..."
          supabase link --project-ref ${{ secrets.SUPABASE_PROD_PROJECT_REF }}

          echo "üöÄ Applying ${{ steps.check-migrations.outputs.count }} migration(s) to PRODUCTION database..."
          echo "   This will apply all pending migrations from supabase/migrations/"

          supabase db push

          echo "‚úÖ Production migrations applied successfully"

      - name: Create deployment marker
        run: |
          echo "::notice::Production database migrations applied at $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo ""
          echo "‚úÖ PRODUCTION DATABASE UPDATED"
          echo "   Migrations applied successfully"
          echo "   Vercel deployment will follow automatically"

  # Job 4: Verify deployment health
  verify-deployment:
    name: Verify Production Deployment
    runs-on: ubuntu-latest
    needs: apply-migrations-to-production
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    timeout-minutes: 10

    steps:
      - name: Wait for Vercel deployment
        run: |
          echo "‚è≥ Waiting 90 seconds for Vercel to deploy..."
          echo "   (Vercel auto-deploys when main branch is updated)"
          sleep 90

      - name: Health check production
        run: |
          echo "üè• Running health check on production..."

          # Replace with your actual production URL
          PROD_URL="https://service.vercel.app"

          # Attempt health check (retry up to 3 times)
          for i in 1 2 3; do
            echo "Attempt $i/3..."
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" $PROD_URL/api/health || echo "000")
            
            if [ "$RESPONSE" == "200" ]; then
              echo "‚úÖ Production is healthy (HTTP $RESPONSE)"
              exit 0
            else
              echo "‚ö†Ô∏è  Health check returned: $RESPONSE"
              if [ $i -lt 3 ]; then
                echo "   Retrying in 30 seconds..."
                sleep 30
              fi
            fi
          done

          echo "‚ùå Production health check failed after 3 attempts"
          echo "   Manual verification required"
          echo "   Check Vercel deployment logs: https://vercel.com/set4tech/service"
          exit 1

      - name: Deployment successful
        run: |
          echo "üéâ Deployment complete and verified!"
          echo ""
          echo "Summary:"
          echo "  ‚úÖ Migrations tested on production branch"
          echo "  ‚úÖ E2E tests passed"
          echo "  ‚úÖ Migrations applied to production"
          echo "  ‚úÖ Application deployed"
          echo "  ‚úÖ Health check passed"
